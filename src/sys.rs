//!
//! Bindings to the Binder kernel interface.
//!
//! This file is mostly autogenerated from the kernel C headers. They contain
//! all the datastructures necessary to communicate with the kernel drivers,
//! along with wrappers around all the ioctls.
//!
// TODO: Document everything in this crate. I could probably document most of
// it by scourging through my notes.

#![allow(bad_style)]

use std::fmt::{Debug, Formatter, Error as FmtError};
use std::mem::size_of;

#[cfg(BINDER_IPC_32BIT)]
pub type binder_size_t = u32;
#[cfg(BINDER_IPC_32BIT)]
pub type binder_uintptr_t = u32;
#[cfg(not(BINDER_IPC_32BIT))]
pub type binder_size_t = u64;
#[cfg(not(BINDER_IPC_32BIT))]
pub type binder_uintptr_t = u64;

use libc::{pid_t, uid_t};

#[cfg(BINDER_IPC_32BIT)]
pub const CurrentProtocolVersion: i32 = 7;
#[cfg(not(BINDER_IPC_32BIT))]
pub const CurrentProtocolVersion: i32 = 8;

pub(crate) const fn pack_chars(c1: u8, c2: u8, c3: u8, c4: u8) -> u32 {
    ((((c1 as u32)<<24)) | (((c2 as u32)<<16)) | (((c3 as u32)<<8)) | (c4 as u32))
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BinderType {
    Binder = pack_chars(b's', b'b', b'*', 0x85),
    WeakBinder = pack_chars(b'w', b'b', b'*', 0x85),
    Handle = pack_chars(b's', b'h', b'*', 0x85),
    WeakHandle = pack_chars(b'w', b'h', b'*', 0x85),
    Fd = pack_chars(b'f', b'd', b'*', 0x85),
}

// TODO: Convert to consts or bitflags
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FlatBinderFlag {
    PriorityMask = 0xff,
    AcceptsFds = 0x100,
}

#[repr(C)]
#[derive(Copy)]
pub struct flat_binder_object {
    pub type_: u32,
    pub flags: u32,
    pub target: flat_binder_object__bindgen_ty_1,
    pub cookie: binder_uintptr_t,
}

#[repr(C)]
#[derive(Copy)]
pub union flat_binder_object__bindgen_ty_1 {
    pub binder: binder_uintptr_t,
    pub handle: u32,
}

impl Debug for flat_binder_object__bindgen_ty_1 {
    // Worst-case scenario, we print some stack data. It's not too bad.
    // TODO: Use {:p} ?
    fn fmt(&self, f: &mut Formatter) -> Result<(), FmtError> {
        unsafe {
            write!(f, "union {{ binder = {:#x}, handle = {} }}", self.binder, self.handle)
        }
    }
}

impl Clone for flat_binder_object__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}

impl Clone for flat_binder_object {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct binder_write_read {
    pub write_size: binder_size_t,
    pub write_consumed: binder_size_t,
    pub write_buffer: binder_uintptr_t,
    pub read_size: binder_size_t,
    pub read_consumed: binder_size_t,
    pub read_buffer: binder_uintptr_t,
}

impl Clone for binder_write_read {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct binder_version {
    pub protocol_version: i32,
}

impl Clone for binder_version {
    fn clone(&self) -> Self { *self }
}

bitflags! {
    pub struct TransactionFlags: u32 {
        const TF_ONE_WAY = 0x01;
        const TF_ROOT_OBJECT = 0x04;
        const TF_STATUS_CODE = 0x08;
        const TF_ACCEPT_FDS = 0x10;
    }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct binder_transaction_data {
    pub target: binder_transaction_data__bindgen_ty_1,
    pub cookie: binder_uintptr_t,
    pub code: u32,
    pub flags: u32,
    pub sender_pid: pid_t,
    pub sender_euid: uid_t,
    pub data_size: binder_size_t,
    pub offsets_size: binder_size_t,
    pub data: binder_transaction_data__bindgen_ty_2,
}

#[repr(C)]
#[derive(Copy)]
pub union binder_transaction_data__bindgen_ty_1 {
    pub handle: u32,
    pub ptr: binder_uintptr_t,
}

impl Debug for binder_transaction_data__bindgen_ty_1 {
    // Worst-case scenario, we print some stack data. It's not too bad.
    fn fmt(&self, f: &mut Formatter) -> Result<(), FmtError> {
        unsafe {
            write!(f, "union {{ handle = {}, ptr = {:#x} }}", self.handle, self.ptr)
        }
    }
}

impl Clone for binder_transaction_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Copy)]
pub union binder_transaction_data__bindgen_ty_2 {
    pub ptr: binder_transaction_data__bindgen_ty_2__bindgen_ty_1,
    pub buf: [u8; 8usize],
}

impl Debug for binder_transaction_data__bindgen_ty_2 {
    // Worst-case scenario, we print some stack data. It's not too bad.
    fn fmt(&self, f: &mut Formatter) -> Result<(), FmtError> {
        unsafe {
            write!(f, "union {{ ptr = {:?}, buf = {:?} }}", self.ptr, self.buf)
        }
    }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct binder_transaction_data__bindgen_ty_2__bindgen_ty_1 {
    pub buffer: binder_uintptr_t,
    pub offsets: binder_uintptr_t,
}

impl Clone for binder_transaction_data__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}

impl Clone for binder_transaction_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}

impl Clone for binder_transaction_data {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct binder_ptr_cookie {
    pub ptr: binder_uintptr_t,
    pub cookie: binder_uintptr_t,
}

impl Clone for binder_ptr_cookie {
    fn clone(&self) -> Self { *self }
}

#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct binder_handle_cookie {
    pub handle: u32,
    pub cookie: binder_uintptr_t,
}

impl Clone for binder_handle_cookie {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct binder_pri_desc {
    pub priority: i32,
    pub desc: u32,
}

impl Clone for binder_pri_desc {
    fn clone(&self) -> Self { *self }
}

#[repr(C)]
#[derive(Debug, Copy)]
pub struct binder_pri_ptr_cookie {
    pub priority: i32,
    pub ptr: binder_uintptr_t,
    pub cookie: binder_uintptr_t,
}

impl Clone for binder_pri_ptr_cookie {
    fn clone(&self) -> Self { *self }
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ReturnProtocol {
    Error = ior!('r', 0, size_of::<i32>()) as i32,
    Ok = io!('r', 1) as i32,
    Transaction = ior!('r', 2, size_of::<binder_transaction_data>()) as i32,
    Reply = ior!('r', 3, size_of::<binder_transaction_data>()) as i32,
    AcquireResult = ior!('r', 4, size_of::<i32>()) as i32,
    DeadReply = io!('r', 5) as i32,
    TransactionComplete = io!('r', 6) as i32,
    IncRefs = ior!('r', 7, size_of::<binder_ptr_cookie>()) as i32,
    Acquire = ior!('r', 8, size_of::<binder_ptr_cookie>()) as i32,
    Release = ior!('r', 9, size_of::<binder_ptr_cookie>()) as i32,
    DecRefs = ior!('r', 10, size_of::<binder_ptr_cookie>()) as i32,
    AttemptAcquire = ior!('r', 11, size_of::<binder_pri_ptr_cookie>()) as i32,
    Noop = io!('r', 12) as i32,
    SpawnLooper = io!('r', 13) as i32,
    Finished = io!('r', 14) as i32,
    DeadBinder = ior!('r', 15, size_of::<binder_uintptr_t>()) as i32,
    ClearDeathNotificationDone = ior!('r', 16, size_of::<binder_uintptr_t>()) as i32,
    FailedReply = io!('r', 17) as i32,
}

impl ReturnProtocol {
    pub fn from_primitive(u: i32) -> Option<ReturnProtocol> {
        use self::ReturnProtocol::*;
            // TODO: Use the io/ior/iow macros
        if u == ior!('r', 0, size_of::<i32>()) { Some(Error) }
        else if u == io!('r', 1) { Some(Ok) }
        else if u == ior!('r', 2, size_of::<binder_transaction_data>()) { Some(Transaction) }
        else if u == ior!('r', 3, size_of::<binder_transaction_data>()) { Some(Reply) }
        else if u == ior!('r', 4, size_of::<i32>()) { Some(AcquireResult) }
        else if u == io!('r', 5) { Some(DeadReply) }
        else if u == io!('r', 6) { Some(TransactionComplete) }
        else if u == ior!('r', 7, size_of::<binder_ptr_cookie>()) { Some(IncRefs) }
        else if u == ior!('r', 8, size_of::<binder_ptr_cookie>()) { Some(Acquire) }
        else if u == ior!('r', 9, size_of::<binder_ptr_cookie>()) { Some(Release) }
        else if u == ior!('r', 10, size_of::<binder_ptr_cookie>()) { Some(DecRefs) }
        else if u == ior!('r', 11, size_of::<binder_pri_ptr_cookie>()) { Some(AttemptAcquire) }
        else if u == io!('r', 12) { Some(Noop) }
        else if u == io!('r', 13) { Some(SpawnLooper) }
        else if u == io!('r', 14) { Some(Finished) }
        else if u == ior!('r', 15, size_of::<binder_uintptr_t>()) { Some(DeadBinder) }
        else if u == ior!('r', 16, size_of::<binder_uintptr_t>()) { Some(ClearDeathNotificationDone) }
        else if u == io!('r', 17) { Some(FailedReply) }
        else { None }
    }
}

#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CommandProtocol {
    Transaction = iow!('c', 0, size_of::<binder_transaction_data>()) as u32,
    Reply = iow!('c', 1, size_of::<binder_transaction_data>()) as u32,
    AcquireResult = iow!('c', 2, size_of::<i32>()) as u32,
    FreeBuffer = iow!('c', 3, size_of::<binder_uintptr_t>()) as u32,
    IncRefs = iow!('c', 4, size_of::<u32>()) as u32,
    Acquire = iow!('c', 5, size_of::<u32>()) as u32,
    Release = iow!('c', 6, size_of::<u32>()) as u32,
    DecRefs = iow!('c', 7, size_of::<u32>()) as u32,
    IncRefsDone = iow!('c', 8, size_of::<binder_ptr_cookie>()) as u32,
    AcquireDone = iow!('c', 9, size_of::<binder_ptr_cookie>()) as u32,
    AttemptAcquire = iow!('c', 10, size_of::<binder_pri_desc>()) as u32,
    RegisterLooper = io!('c', 11) as u32,
    EnterLooper = io!('c', 12) as u32,
    ExitLooper = io!('c', 13) as u32,
    RequestDeathNotification = iow!('c', 14, size_of::<binder_handle_cookie>()) as u32,
    ClearDeathNotification = iow!('c', 15, size_of::<binder_handle_cookie>()) as u32,
    DeadBinderDone = iow!('c', 16, size_of::<binder_uintptr_t>()) as u32,
}

ioctl! {
    /// The main ioctl, allows the binder protocol to advance.
    readwrite binder_write_read with b'b', 1; binder_write_read
}
ioctl!(write_ptr binder_set_idle_timeout with b'b', 3; i64);
ioctl!(write_ptr binder_set_max_threads with b'b', 5; u32);
ioctl!(write_ptr binder_set_idle_priority with b'b', 6; i32);
ioctl! {
    /// Sets the magic handle "0" to the current binder connection.
    ///
    /// Should only be called once during the whole lifetime of the kernel driver.
    ///
    /// On a standard Android install, this is done by the ServiceManager process.
    /// When a process opens a connection to binder, it will then connect to this
    /// service (because the handler 0 always exists and is always the context
    /// object) and use it to discover, connect or create other services.
    ///
    /// Note that on Android, a service managed by the Service Manager is different
    /// from a service created by an App. Only system apps create "top-level"
    /// services. App services are managed by the ActivityManager service.
    write_ptr binder_set_context_mgr with b'b', 7; i32
}
ioctl!(write_ptr binder_thread_exit with b'b', 8; i32);
ioctl! {
    /// Used to make sure that the version of binder we use is the same version the
    /// Kernel uses.
    ///
    /// Note that there are two versions of the Binder protocol in the kernel tree.
    /// The version used is selected at kernel compile-time depending on the
    /// architecture used. 64-bit targets use version 8, while 32-bit use version 7.
    ///
    /// In rust-binder, the version is chosen with the BINDER_IPC_32BIT cfg
    /// attribute.
    ///
    /// TODO: Eventually, this will be exposed as a crate feature, or maybe even
    /// dynamically figured out (which would be an improvement over libbinder). But
    /// for now, we basically only allow version 7 (the 32-bit variant).
    readwrite binder_version with b'b', 9; binder_version
}
